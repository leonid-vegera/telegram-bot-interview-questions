{
  "common": [
    {
      "id": 2,
      "text": "Що відрізняє хороший код від поганого?",
      "hasOptions": false,
      "answer": "Гарний код відрізняється читабельністю, ефективністю, масштабованістю, надійністю, елегантністю та відповідністю стандартам. Він також тестований і легко зрозумілий для інших розробників."
    },
    {
      "id": 3,
      "text": "Які HTTP-методи зазвичай використовуються в RESTful веб-сервісах?",
      "hasOptions": false,
      "answer": "У RESTful веб-сервісах часто використовуються такі HTTP-методи:\n1. GET: для отримання ресурсів.\n2. POST: для створення нових ресурсів.\n3. PUT: для оновлення існуючих ресурсів або створення нових.\n4. DELETE: для видалення ресурсів.\n5. PATCH: для часткового оновлення ресурсів."
    },
    {
      "id": 4,
      "text": "У чому небезпека виконання коду, що надходить від користувача?",
      "hasOptions": false,
      "answer": "Виконання коду, наданого користувачем, може створити серйозні загрози для безпеки системи. Можливість використання вразливостей в коді може призвести до атак, таких як ін'єкція коду, де зловмисник може впровадити та виконати свій власний код. Це може призвести до розголошення конфіденційної інформації, втрати контролю над системою або викликати інші види шкідливих впливів. Тому важливо надійно фільтрувати та перевіряти вхідні дані, а також обмежувати можливість виконання коду зовнішніх джерел."
    },
    {
      "id": 5,
      "text": "Що таке ООП?",
      "hasOptions": false,
      "answer": "Об'єктно-орієнтоване програмування (ООП) — це парадигма програмування, яка базується на концепції об'єктів, які можуть містити дані у вигляді полів (атрибутів) і коду у вигляді процедур (методів). Головні принципи ООП включають спадкування (властивість об'єктів переймати характеристики і поведінку від інших об'єктів), інкапсуляцію (зміна даних об'єкта відбувається тільки через його методи), та поліморфізм (одна і та ж сама операція може вести себе по-різному в залежності від класу об'єкта, який її викликає). ООП дозволяє створювати більш підтримувані, розширювані та багатофункціональні програми."
    },
    {
      "id": 6,
      "text": "Яка різниця між класом і абстрактним класом?",
      "hasOptions": false,
      "answer": "Клас і абстрактний клас є об'єктно-орієнтованими концепціями, але мають деякі відмінності. Клас - це шаблон для створення об'єктів, який визначає атрибути (властивості) і методи (процедури) об'єктів. Абстрактний клас - це клас, який не може бути визначений як об'єкт і може містити абстрактні методи, тобто методи, які не мають реалізації в самому класі, але повинні бути реалізовані в підкласах. Інша важлива різниця полягає в тому, що об'єкти не можуть бути створені від абстрактного класу, але вони можуть бути створені від конкретного класу."
    }
  ],
  "html": [
    {
      "id": 1,
      "text": "Який тег використовується для створення посилання?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<link>", "isCorrect": false },
        { "id": 2, "text": "<a>", "isCorrect": true },
        { "id": 3, "text": "<href>", "isCorrect": false },
        { "id": 4, "text": "<anchor>", "isCorrect": false }
      ]
    },
    {
      "id": 2,
      "text": "Який тег використовується для вставлення зображення?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<img>", "isCorrect": true },
        { "id": 2, "text": "<picture>", "isCorrect": false },
        { "id": 3, "text": "<media>", "isCorrect": false },
        { "id": 4, "text": "<graphic>", "isCorrect": false }
      ]
    },
    {
      "id": 3,
      "text": "Який тег знаходиться у <html> визначає заголовок документа?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<head>", "isCorrect": true },
        { "id": 2, "text": "<header>", "isCorrect": false },
        { "id": 3, "text": "<title>", "isCorrect": false },
        { "id": 4, "text": "<meta>", "isCorrect": false }
      ]
    },
    {
      "id": 4,
      "text": "Який атрибут використовується для визначення альтернативного зображення?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "src", "isCorrect": false },
        { "id": 2, "text": "alt", "isCorrect": true },
        { "id": 3, "text": "title", "isCorrect": false },
        { "id": 4, "text": "href", "isCorrect": false }
      ]
    },
    {
      "id": 5,
      "text": "Який атрибут дає змогу відкрити посилання в новій вкладці?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "target=_blank", "isCorrect": true },
        { "id": 2, "text": "target=blank", "isCorrect": false },
        { "id": 3, "text": "target=_self", "isCorrect": false },
        { "id": 4, "text": "target=_new", "isCorrect": false }
      ]
    },
    {
      "id": 6,
      "text": "Навіщо використовується атрибут 'placeholder'?",
      "hasOptions": false,
      "answer": "Атрибут 'placeholder' використовується для відображення текстової підказки або прикладу введення в поле форми до того, як користувач почне вводити свої дані."    },
    {
      "id": 7,
      "text": "Як створити непронумерований список у HTML?",
      "hasOptions": false,
      "answer": "Для створення такого списку в HTML використовується тег <code>ul</code>, а для визначення кожного пункту списку - тег <code>li</code>."    },
    {
      "id": 8,
      "text": "Що таке HTML?",
      "hasOptions": false,
      "answer": "HTML (HyperText Markup Language) - це стандартизована мова розмітки, яка використовується для створення та розробки веб-сторінок. Це система для розмітки окремих частин веб-сторінки з використанням тегів, укладених у кутові дужки."    },
    {
      "id": 9,
      "text": "Що робить тег <!DOCTYPE>?",
      "hasOptions": false,
      "answer": "`Це декларація, яка інформує веб-браузер про версію мови розмітки, використану під час створення веб-сторінки. Це допомагає браузеру коректно відобразити сторінку."    },
    {
      "id": 10,
      "text": "Який тег використовується для створення таблиці?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<table>", "isCorrect": true },
        { "id": 2, "text": "<grid>", "isCorrect": false },
        { "id": 3, "text": "<row>", "isCorrect": false },
        { "id": 4, "text": "<column>", "isCorrect": false }
      ]
    },
    {
      "id": 11,
      "text": "Який тег використовується для створення заголовка таблиці?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<caption>", "isCorrect": false },
        { "id": 2, "text": "<th>", "isCorrect": false },
        { "id": 3, "text": "<thead>", "isCorrect": true },
        { "id": 4, "text": "<title>", "isCorrect": false }
      ]
    },
    {
      "id": 12,
      "text": "Який тег використовується для створення рядка таблиці?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<td>", "isCorrect": false },
        { "id": 2, "text": "<row>", "isCorrect": false },
        { "id": 3, "text": "<line>", "isCorrect": false },
        { "id": 4, "text": "<tr>", "isCorrect": true }
      ]
    },
    {
      "id": 13,
      "text": "Який тег використовується для створення ячейки таблиці?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<cell>", "isCorrect": false },
        { "id": 2, "text": "<tr>", "isCorrect": false },
        { "id": 3, "text": "<th>", "isCorrect": false },
        { "id": 4, "text": "<td>", "isCorrect": true }
      ]
    },
    {
      "id": 14,
      "text": "Що таке семантичні теги в HTML?",
      "hasOptions": false,
      "answer": "Семантичні теги в HTML - це теги, які передають інформацію про зміст або призначення вмісту, а не тільки про його зовнішній вигляд. Приклади семантичних тегів: header, footer, article, section, nav та ін. Вони допомагають створювати більше структуровані та доступні веб-сторінки."    },
    {
      "id": 15,
      "text": "Який атрибут використовується для встановлення фонового зображення?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "background", "isCorrect": false },
        { "id": 2, "text": "background-color", "isCorrect": false },
        { "id": 3, "text": "bgcolor", "isCorrect": false },
        { "id": 4, "text": "background-image", "isCorrect": true }
      ]
    },
    {
      "id": 16,
      "text": "Який тег використовується для створення списку, що випадає?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<dropdown>", "isCorrect": false },
        { "id": 2, "text": "<list>", "isCorrect": false },
        { "id": 3, "text": "<select>", "isCorrect": true },
        { "id": 4, "text": "<option>", "isCorrect": false }
      ]
    },
    {
      "id": 17,
      "text": "Який тег використовується для вставлення JavaScript коду в HTML документ?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<javascript>", "isCorrect": false },
        { "id": 2, "text": "<script>", "isCorrect": true },
        { "id": 3, "text": "<js>", "isCorrect": false },
        { "id": 4, "text": "<java>", "isCorrect": false }
      ]
    },
    {
      "id": 18,
      "text": "Який атрибут використовується для вказівки шляху до зображення?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "src", "isCorrect": true },
        { "id": 2, "text": "href", "isCorrect": false },
        { "id": 3, "text": "path", "isCorrect": false },
        { "id": 4, "text": "url", "isCorrect": false }
      ]
    },
    {
      "id": 19,
      "text": "Що робить атрибут 'readonly' в елементі форми?",
      "hasOptions": false,
      "answer": "Атрибут 'readonly' робить елемент форми тільки для читання, що означає, що користувач не може змінювати значення елемента, але може переглядати його. Це може бути корисним, якщо ви хочете відобразити інформацію, яка не повинна бути змінена."    },
    {
      "id": 20,
      "text": "Що таке веб-стандарти і навіщо вони потрібні?",
      "hasOptions": false,
      "answer": "Веб-стандарти - це рекомендації, розроблені групами стандартів, такими як W3C або WHATWG, для забезпечення сумісності та стійкості веб-технологій. Вони включають рекомендації щодо HTML, CSS, JavaScript та інших веб-технологій. Дотримання веб-стандартів допомагає забезпечити коректну роботу веб-сторінок у різних браузерах та пристроях, а також полегшити обслуговування та розширення веб-сайтів у майбутньому."    },
    {
      "id": 21,
      "text": "Що таке чуйний (responsive) веб-дизайн?",
      "hasOptions": false,
      "answer": "Це підхід до веб-дизайну, який дозволяє веб-сторінкам коректно відображатися та функціонувати на різних пристроях, включаючи мобільні телефони, планшети та настільні комп'ютери, шляхом використання гнучких макетів, гнучких зображень та CSS медіазапитів для адаптації дизайну до різних розмірів екрана та характеристик пристроїв."    },
    {
      "id": 22,
      "text": "Який HTML-тег використовується для вставки відео?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<media>", "isCorrect": false },
        { "id": 2, "text": "<video>", "isCorrect": true },
        { "id": 3, "text": "<movie>", "isCorrect": false },
        { "id": 4, "text": "<multimedia>", "isCorrect": false }
      ]
    },
    {
      "id": 23,
      "text": "Який тег використовується для створення головного заголовка на веб-сторінці?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<h1>", "isCorrect": true },
        { "id": 2, "text": "<header>", "isCorrect": false },
        { "id": 3, "text": "<title>", "isCorrect": false },
        { "id": 4, "text": "<head>", "isCorrect": false }
      ]
    },
    {
      "id": 24,
      "text": "Що робить тег <br>?",
      "hasOptions": false,
      "answer": "Він використовується для перенесення рядка, що дозволяє створити новий рядок у тому місці, де він розміщений. Це зручний спосіб керування розташуванням тексту на веб-сторінці без використання додаткових стилів або елементів."    },
    {
      "id": 25,
      "text": "Який тег використовується для створення впорядкованого списку?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<ul>", "isCorrect": false },
        { "id": 2, "text": "<ol>", "isCorrect": true },
        { "id": 3, "text": "<li>", "isCorrect": false },
        { "id": 4, "text": "<list>", "isCorrect": false }
      ]
    },
    {
      "id": 26,
      "text": "Що таке DOM у контексті веб-розробки?",
      "hasOptions": false,
      "answer": "DOM (Document Object Model) - це програмний інтерфейс для веб-документів. Це представлення структурованого документа у вигляді об'єктної моделі, яке дозволяє програмам і скриптам взаємодіяти з вмістом, структурою та стилями веб-сторінки. DOM представляє документ як дерево об'єктів, кожен з яких відповідає частині сторінки."    },
    {
      "id": 27,
      "text": "Який атрибут використовується для визначення стилів елемента на сторінці?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "style", "isCorrect": true },
        { "id": 2, "text": "css", "isCorrect": false },
        { "id": 3, "text": "styles", "isCorrect": false },
        { "id": 4, "text": "stylesheet", "isCorrect": false }
      ]
    },
    {
      "id": 28,
      "text": "Що таке атрибут 'alt' у тезі <img>?",
      "hasOptions": false,
      "answer": "Він використовується для надання альтернативного тексту, який відображатиметься у випадку, якщо зображення не може бути завантажене. Це також може бути корисним для забезпечення доступності, оскільки скрін-рідери можуть використовувати цей текст для опису зображення користувачам з обмеженими можливостями. "
    },
    {
      "id": 29,
      "text": "Що таке DOCTYPE і навіщо його використовують?",
      "hasOptions": false,
      "answer": "DOCTYPE (Document Type Declaration) - це інструкція, яка вказує веб-браузеру, як правильно трактувати HTML-документ. Вона зазвичай розташована на початку HTML-коду. DOCTYPE визначає версію HTML або XHTML, яку використовує документ. Використання DOCTYPE є важливим для забезпечення правильного відображення сторінки в різних браузерах, адже вказання правильного DOCTYPE дозволяє браузерам переключитися в режим сумісності з конкретною версією HTML та коректно інтерпретувати структуру документа."
    },
    {
      "id": 30,
      "text": "Які теги з найсвіжіших оновлень ви знаєте?",
      "hasOptions": false,
      "answer": "Деякі з найсвіжіших оновлень HTML включають такі теги:\n1. <article>: для представлення контенту, який може існувати сам по собі.\n2. <section>: для групування схожого контенту, який може мати власну тему.\n3. <nav>: для визначення блоку навігації.\n4. <header>: для визначення верхньої частини сторінки або розділу.\n5. <footer>: для визначення нижньої частини сторінки або розділу."
    },
    {
      "id": 31,
      "text": "Що таке data-атрибути, в яких випадках їх використовуєте?",
      "hasOptions": false,
      "answer": "Data-атрибути в HTML — це атрибути, які починаються з префіксу 'data-', і призначені для зберігання користувацьких даних в елементах. Вони дозволяють вбудовувати додаткову інформацію без втручання в стандартні атрибути. Data-атрибути дуже корисні в ситуаціях, коли потрібно зберегти додаткові дані, які можуть бути використані для скриптів, стилів чи іншого коду. Наприклад, використовують data-атрибути для зберігання ідентифікаторів, параметрів або іншої інформації, яка може знадобитися у веб-розробці."
    },
    {
      "id": 32,
      "text": "Яка різниця між атрибутами 'class' та 'id' в HTML?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "class - можна використовувати для стилізації одночасно декількох елементів, id - повинен бути унікальним на сторінці", "isCorrect": true },
        { "id": 2, "text": "class - повинен бути унікальним на сторінці, id - можна використовувати для стилізації одночасно декількох елементів", "isCorrect": false },
        { "id": 3, "text": "class - використовується для визначення ідентифікатора елемента, id - для групування елементів", "isCorrect": false },
        { "id": 4, "text": "class і id - обидва можна використовувати для стилізації будь-якої кількості елементів", "isCorrect": false }
      ]
    },
    {
      "id": 33,
      "text": "Що таке внутрішні та зовнішні гіперпосилання і які вони мають атрибути?",
      "hasOptions": false,
      "answer": "Внутрішні гіперпосилання (внутрішні посилання) вказують на ресурси, які знаходяться в межах того самого веб-сайту. Зовнішні гіперпосилання (зовнішні посилання) спрямовують на ресурси за межами поточного веб-сайту. Атрибути гіперпосилань включають:\n1. href - визначає адресу ресурсу для посилання.\n2. target - визначає, де має відкриватися посилання (наприклад, у тому ж вікні чи в новому вікні).\n3. title - надає текстовий опис, який з'являється при наведенні курсора."
    },
    {
      "id": 34,
      "text": "Що ви знаєте про SVG?",
      "hasOptions": false,
      "answer": "SVG (Scalable Vector Graphics) - це формат графіки на основі XML, який використовується для відображення векторної графіки в браузерах та інших програмах. Основні особливості SVG включають масштабованість без втрат якості, векторну природу графіки, інтерактивність, підтримку текстових та графічних елементів, а також можливість використання CSS і JavaScript для стилізації та додавання функціональності."
    },
    {
      "id": 35,
      "text": "Як можна додати SVG на сторінку сайту?",
      "hasOptions": false,
      "answer": "Є кілька способів додавання SVG на сторінку сайту:\n1. Вбудований SVG-код безпосередньо в HTML-файл.\n2. Посилання на зовнішній файл SVG за допомогою тегу <img>.\n3. Використання тегу <object> для вставки зовнішнього SVG-файлу.\n4. Використання CSS background для вбудовання SVG як фону елементу."
    },
    {
      "id": 36,
      "text": "Як правильно визначити коло в SVG?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<circle cx='50' cy='50' r='30' />", "isCorrect": true },
        { "id": 2, "text": "<rectangle x='50' y='50' width='30' height='30' />", "isCorrect": false },
        { "id": 3, "text": "<ellipse cx='50' cy='50' rx='30' ry='20' />", "isCorrect": false },
        { "id": 4, "text": "<path d='M50 20 A30 30 0 1 1 20 50 Z' />", "isCorrect": false }
      ]
    },
    {
      "id": 37,
      "text": "Як визначити лінію в SVG?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<line x1='10' y1='10' x2='50' y2='50' />", "isCorrect": true },
        { "id": 2, "text": "<path d='M10 10 L50 50' />", "isCorrect": false },
        { "id": 3, "text": "<polygon points='10,10 50,10 50,50' />", "isCorrect": false },
        { "id": 4, "text": "<rect x='10' y='10' width='40' height='2' />", "isCorrect": false }
      ]
    },
    {
      "id": 38,
      "text": "Як створити форму в HTML і забезпечити її валідацію?",
      "hasOptions": false,
      "answer": "Для створення форми в HTML використовують тег <form>. Наприклад:\n\n```html\n<form action='/submit' method='post' id='myForm'>\n  <!-- Елементи форми, такі як input, textarea, select та інші -->\n</form>\n```\n\nЩоб забезпечити валідацію, можна використовувати вбудовані атрибути та JavaScript. Декілька прикладів:\n1. Використання атрибутів HTML5, таких як required, pattern і т.д.\n2. Використання JavaScript для кастомної валідації перед відправленням форми.\n3. Використання бібліотек для валідації форм, таких як jQuery Validation або більш сучасних рішень."
    },
    {
      "id": 39,
      "text": "Що таке <iframe> і для чого його використовують?",
      "hasOptions": false,
      "answer": "<iframe> - це HTML-тег, який використовується для вставки вмісту іншого документа в поточний документ. Використовується для вставки веб-сторінок, відео, карток тощо. <iframe> має атрибути, такі як 'src' (вказує на посилання на вміст), 'width' і 'height' (вказують розміри фрейму), 'frameborder' (визначає відображення рамки), 'allowfullscreen' (дозволяє вмісту фрейму заповнювати весь екран у режимі повного екрану) та інші. Використовується для вбудовування контенту з інших джерел на веб-сторінці."
    },
    {
      "id": 40,
      "text": "Які основні відмінності між блоковими та вбудованими елементами в HTML?",
      "hasOptions": false,
      "answer": "Блокові елементи в HTML зазвичай займають всю доступну ширину, розташовуються один над одним, можуть містити інші блокові та вбудовані елементи. Вбудовані елементи займають тільки стільки місця, скільки потрібно для відображення свого вмісту, розташовуються поруч один з одним та ігнорують ширину та висоту."
    },
    {
      "id": 41,
      "text": "Як працює наслідування в CSS?",
      "hasOptions": false,
      "answer": "У CSS наслідування - це механізм, за яким деякі властивості елементів автоматично успадковуються від їхніх батьківських елементів. Наприклад, колір тексту та розмір шрифту можуть успадковуватися від батьківського елементу до його дочірніх елементів. Однак не всі властивості успадковуються, і це може бути змінено за допомогою спеціальних значень, таких як 'inherit' або 'initial'."
    },
    {
      "id": 42,
      "text": "Що таке «модель коробки» в CSS і як її можна змінити?",
      "hasOptions": false,
      "answer": "Модель коробки в CSS визначає, як браузер розраховує розміри та розміщення елементів на веб-сторінці. Вона включає ширину та висоту елемента, внутрішні та зовнішні відступи, а також рамки. Модель коробки можна змінити за допомогою властивостей CSS, таких як 'box-sizing'. Значення 'box-sizing: border-box;' робить так, що ширина та висота елемента включають в себе внутрішні та зовнішні відступи та рамки, що полегшує розрахунок розмірів елементів."
    },
    {
      "id": 43,
      "text": "Як можна приховати елемент за допомогою CSS?",
      "hasOptions": false,
      "answer": "Існує кілька способів приховати елемент за допомогою CSS:\n\n1. Використання 'display: none;': Ця властивість приховує елемент і забирає його місце в потоці документу.\n\n2. Використання 'visibility: hidden;': Ця властивість робить елемент невидимим, але він залишається на місці, зберігаючи місце в потоці.\n\n3. Використання 'opacity: 0;': Ця властивість робить елемент прозорим, зроблюючи його невидимим, але елемент все ще займає місце в потоці.\n\n4. Використання 'position: absolute; left: -9999px;': Цей метод зсуває елемент за межі видимої області, залишаючи його прихованим."
    },
    {
      "id": 44,
      "text": "Що таке Document Object Model?",
      "hasOptions": false,
      "answer": "Document Object Model (DOM) - це програмний інтерфейс, який представляє структуру документа веб-сторінки у вигляді дерева об'єктів. Кожен елемент HTML сторінки, також включаючи текст, атрибути, інші елементи, створюється як об'єкт в цьому дереві. DOM дозволяє скриптам та програмам змінювати структуру, стиль і зміст документа."
    },
    {
      "id": 45,
      "text": "Які теги зʼявились в HTML5?",
      "hasOptions": false,
      "answer": "HTML5 ввів кілька нових тегів для поліпшення структури і розмітки веб-сторінок. Деякі з них включають <header>, <nav>, <section>, <article>, <aside>, <footer>, <figure>, <figcaption>, <main>, <mark>, <progress>, <output>, <time>, <datalist> та інші."
    },
    {
      "id": 46,
      "text": "Як відбувається центрування блоку по вертикалі?",
      "hasOptions": false,
      "answer": "Для центрування блоку по вертикалі використовують різні методи, включаючи:\n1. Використання flexbox: застосування стилів display: flex; та align-items: center; для контейнера.\n2. Використання grid layout: застосування display: grid; та align-items: center; для контейнера.\n3. Використання позиціонування: застосування стилів position: relative; та top: 50%;, а потім зсування блоку назад на половину його висоти за допомогою transform: translateY(-50%);."
    },
    {
      "id": 47,
      "text": "Назвіть погані практики в HTML.",
      "hasOptions": false,
      "answer": "Деякі погані практики в HTML включають:\n1. Використання застарілих та несемантичних тегів, таких як <font>, <center>, <b>, <i>.\n2. Вкладення стилів безпосередньо в HTML-код за допомогою атрибута style, замість використання CSS-файлів.\n3. Використання таблиць для створення макету сторінки, якщо це не є табличною інформацією.\n4. Незакриття тегів або неправильне вкладення тегів, що може призводити до проблем у відображенні сторінки."
    },
    {
      "id": 48,
      "text": "Що таке BEM?",
      "hasOptions": false,
      "answer": "BEM (Block, Element, Modifier) - це методологія неймінгу та організації коду для веб-розробки. Вона спрямована на покращення читабельності, підтримуваності та масштабованості коду CSS та HTML. BEM використовує простий підхід до неймінгу класів, розбиваючи їх на блоки (blocks), елементи (elements) та модифікатори (modifiers). Це дозволяє створювати структурований і підтримуваний код, особливо великих проектах."
    }
  ],
  "css": [
    {
      "id": 1,
      "text": "У чому різниця між «скиданням» та «нормалізацією» CSS? Що б ви обрали і чому?",
      "hasOptions": false,
      "answer": "Скидання (reset) скидає всі вбудовані в браузер стилі елементів. Normalize наводить стилі до єдиного вигляду у всіх браузерах. Краще використовувати Normalize через кросбраузерність."    },
    {
      "id": 2,
      "text": "Що таке специфічність CSS селекторів і як вона працює?",
      "hasOptions": false,
      "answer": "Специфічність селектора (ще називають вагою) це властивість, що визначає пріоритет стильового правила, тобто те, який стиль буде застосований до HTML елементу в результаті. Наприклад, використовуючи якусь UI бібліотеку, елементам цієї бібліотеки будуть застосовані правила задані авторами за замовчуванням: При необхідності можна поміняти стилі на свої, «перебивши» дефолтні більш специфічним селектором.\n\nДокладніше тут: target='_blank'>Специфічність (MDN)</a>"    },
    {
      "id": 3,
      "text": "Що таке CSS?",
      "hasOptions": false,
      "answer": "CSS (Cascading Style Sheets) - це мова стилів, яка використовується для опису зовнішнього вигляду та форматування документа, написаного мовою розмітки, такою як HTML. CSS дозволяє розробникам керувати макетом, шрифтами, кольорами та іншими стилістичними аспектами веб-сторінки ."    },
    {
      "id": 4,
      "text": "Чому, як правило, краще розмістити підключення CSS у <head>, а <script> перед тегом </body>? Чи знаєте ви якісь винятки, наведіть приклади?",
      "hasOptions": false,
      "answer": "Стилі рекомендується підключати в head для того, щоб сторінка якнайшвидше прийняла свій зовнішній вигляд. Скрипти підключені в head можуть загальмувати цей процес, у зв'язку з цим їх рекомендується підключати перед закриваючим тегом body. Винятком є скрипти аналітики, визначення кількості відвідувачів, які не дочекалися завантаження сторінки. У цьому випадку скрипт повинен бути підключений до head."    },
    {
      "id": 5,
      "text": "Що робить властивість 'z-index' у CSS?",
      "hasOptions": false,
      "answer": "Властивість 'z-index' у CSS контролює стіковий порядок елементів по осі Z. Елемент з більшим значенням 'z-index' буде відображатися поверх елемента з меншим значенням 'z-index'."    },
    {
      "id": 6,
      "text": "Які є способи відцентрувати div?",
      "hasOptions": false,
      "answer": "Існує кілька способів відцентрувати div в CSS, ось деякі з них: \n1. Використання властивостей margin і auto: `margin: 0 auto;`.\n2. Використання Flexbox: `display: flex; justify-content: center;align-items: center;`.\n3.Використання Grid Layout: `display: grid;place-items: center;`.\n4. ` на батьківському елементі та `display: inline-block;` на самому div.`."    },
    {
      "id": 7,
      "text": "Яка властивість використовується для встановлення кольору фону?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "color", "isCorrect": false },
        { "id": 2, "text": "background-color", "isCorrect": true },
        { "id": 3, "text": "bgcolor", "isCorrect": false },
        { "id": 4, "text": "background", "isCorrect": false }
      ]
    },
    {
      "id": 8,
      "text": "Яка властивість дозволяє встановити зовнішні відступи елемента?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "padding", "isCorrect": false },
        { "id": 2, "text": "border", "isCorrect": false },
        { "id": 3, "text": "margin", "isCorrect": true },
        { "id": 4, "text": "spacing", "isCorrect": false }
      ]
    },
    {
      "id": 9,
      "text": "Яка властивість використовується для встановлення шрифту?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "font-weight", "isCorrect": false },
        { "id": 2, "text": "font-style", "isCorrect": false },
        { "id": 3, "text": "text-font", "isCorrect": false },
        { "id": 4, "text": "font-family", "isCorrect": true }
      ]
    },
    {
      "id": 10,
      "text": "Яка властивість CSS дозволяє контролювати видимість елемента в DOM, але при цьому зберігає його місце?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "display: none", "isCorrect": false },
        { "id": 2, "text": "visibility: hidden", "isCorrect": true },
        { "id": 3, "text": "is-visible: 0", "isCorrect": false },
        { "id": 4, "text": "color: transparent", "isCorrect": false }
      ]
    },
    {
      "id": 11,
      "text": "Яка властивість CSS використовується для встановлення тіней елементів?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "box-shadow", "isCorrect": true },
        { "id": 2, "text": "text-shadow", "isCorrect": false },
        { "id": 3, "text": "shadow", "isCorrect": false },
        { "id": 4, "text": "border-shadow", "isCorrect": false }
      ]
    },
    {
      "id": 12,
      "text": "Який селектор вибирає всі елементи .child, які є безпосередніми дочірніми елементами .parent?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": ".parent + .child", "isCorrect": false },
        { "id": 2, "text": ".parent ~ .child", "isCorrect": false },
        { "id": 3, "text": ".parent > .child", "isCorrect": true },
        { "id": 4, "text": ".parent .child", "isCorrect": false }
      ]
    },
    {
      "id": 13,
      "text": "Який селектор CSS вибирає всі елементи, які мають вказаний атрибут, що починається з певного рядка?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "[attr=value]", "isCorrect": false },
        { "id": 2, "text": "[attr~=value]", "isCorrect": false },
        { "id": 3, "text": "[attr|=value]", "isCorrect": false },
        { "id": 4, "text": "[attr^=value]", "isCorrect": true }
      ]
    },
    {
      "id": 14,
      "text": "Який селектор CSS вибирає всі елементи, які мають вказаний атрибут, що закінчується певним рядком?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "[attr=value]", "isCorrect": false },
        { "id": 2, "text": "[attr~=value]", "isCorrect": false },
        { "id": 3, "text": "[attr|=value]", "isCorrect": false },
        { "id": 4, "text": "[attr$=value]", "isCorrect": true }
      ]
    },
    {
      "id": 15,
      "text": "Як правильно підключити зовнішній файл CSS до HTML-сторінки?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<link rel='stylesheet' type='text/css' href='styles.css'>", "isCorrect": false },
        { "id": 2, "text": "<style src='styles.css'>", "isCorrect": false },
        { "id": 3, "text": "<css href='styles.css'>", "isCorrect": false },
        { "id": 4, "text": "<link type='text/css' href='styles.css'>", "isCorrect": true }
      ]
    },
    {
      "id": 16,
      "text": "Які комбінатори селекторів в CSS ви використовуєте для вибору всіх <p> елементів, які є нащадками <div> елемента з класом 'container'?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "div .container p", "isCorrect": false },
        { "id": 2, "text": ".container p", "isCorrect": true },
        { "id": 3, "text": "div + p", "isCorrect": false },
        { "id": 4, "text": ".container > p", "isCorrect": false }
      ]
    },
    {
      "id": 17,
      "text": "Які існують способи CSS оптимізації?",
      "hasOptions": false,
      "answer": "Існує кілька способів оптимізації CSS для поліпшення швидкодії та продуктивності веб-сайтів. Деякі з них включають:\n1. Мінімізація CSS: Видалення зайвих пробілів, переносів рядків та непотрібних символів.\n2. Компресія CSS: Використання спеціальних інструментів для стискання CSS-коду.\n3. Кешування: Використання кешування для збереження стилів на стороні клієнта та їх швидшого завантаження.\n4. Спрощення селекторів: Використання більш ефективних та простих селекторів.\n5. Використання CSS спрайтів: Об'єднання зображень в один файл для зменшення кількості HTTP-запитів.\n6. Використання внутрішніх таблиць стилів: Мінімізація зовнішніх файлів CSS для зменшення затримок завантаження."
    },
    {
      "id": 18,
      "text": "Що таке Media Queries?",
      "hasOptions": false,
      "answer": "Media Queries - це техніка в CSS, яка дозволяє визначати стилі для конкретних умов екрану, таких як ширина вікна перегляду, висота екрану тощо. Вони використовуються для адаптації веб-сайтів до різних пристроїв та екранів."
    },
    {
      "id": 19,
      "text": "Що таке Box Object Model?",
      "hasOptions": false,
      "answer": "Box Object Model (BOM) - це модель, яка визначає структуру і взаємодію елементів на веб-сторінці. Вона включає в себе контент, область наповнення (padding), рамку (border) та зовнішній відступ (margin) елемента."
    },
    {
      "id": 20,
      "text": "Поясніть, що таке псевдокласи (first-child, last-child, active, checked), псевдоелементи (before, after) та псевдоселектори (hover)?",
      "hasOptions": false,
      "answer": "Псевдокласи - це ключові слова, які додають стилі до елементів в залежності від їхнього стану або позиції, такі як :first-child, :last-child, :active, :checked. Псевдоелементи (before, after) додають контент до визначених елементів без наявності їхньої реальної розмітки. Псевдоселектори (hover) визначають стилі для елементів, коли користувач наводить на них курсор."
    },
    {
      "id": 21,
      "text": "Що таке calc, vh, vw, rem, em?",
      "hasOptions": false,
      "answer": "calc - це CSS-функція, яка дозволяє виконувати арифметичні операції в CSS; vh - одиниця вимірювання, що представляє висоту вікна (відсотки від висоти екрану); vw - одиниця вимірювання, що представляє ширину вікна (відсотки від ширини екрану); rem - одиниця вимірювання, яка вказується відносно кореневого елемента (зазвичай html), ідеальна для створення адаптивних дизайнів; em - одиниця вимірювання, яка вказується відносно розміру шрифту батьківського елемента."
    },
    {
      "id": 22,
      "text": "Які ви знаєте способи організації трьохколоночного лейаута?",
      "hasOptions": false,
      "answer": "Існує кілька способів організації трьохколоночного лейаута в CSS, включаючи використання float, flexbox і grid. Float був популярним способом в минулому, проте flexbox і grid стали більш сучасними та потужними інструментами для цього завдання. Flexbox надає гнучкість в розміщенні елементів у контейнері, в той час як grid дозволяє створювати складніші макети з рядками і колонками."
    },
    {
      "id": 23,
      "text": "Що таке Flexbox?",
      "hasOptions": false,
      "answer": "Flexbox (Flexible Box) - це модель розмітки в CSS, яка надає ефективні засоби для розташування та розміщення елементів у контейнері, навіть якщо їх розміри невідомі або змінюються. За допомогою властивостей flex контейнера та його дочірніх елементів, можна створити гнучкі та автономні макети, що легко адаптуються до різних розмірів екранів та умов."
    },
    {
      "id": 24,
      "text": "Що таке Float?",
      "hasOptions": false,
      "answer": "Float в CSS - це властивість, яка розташовує блок або інлайн-елемент вздовж одного з його бортів, так щоб інші елементи обтікали його. Використовується зазвичай для створення глибоких макетів, але також може призводити до ряду проблем, таких як каскадне розташування і нестабільність."
    },
    {
      "id": 25,
      "text": "Що таке Sticky footer та footer always on bottom?",
      "hasOptions": false,
      "answer": "Sticky Footer - це техніка верстки, яка дозволяє розмістити нижній колонтитул (footer) в нижній частині сторінки, навіть якщо вміст сторінки не заповнює весь екран. Це досягається за допомогою властивостей CSS, таких як flexbox або grid, а також використання псевдоелементу ::before для високоступінчастого блоку контейнера. Footer always on bottom означає те саме - створення такого дизайну, де нижній колонтитул завжди розташований в нижній частині сторінки."
    }

  ],
  "javascript": [
    {
      "id": 1,
      "text": "Що таке чиста функція?",
      "hasOptions": false,
      "answer": "Це функція, яка повертає однаковий результат, коли викликається з тим самим набором аргументів, а також не має побічних ефектів (side effects)"    },
    {
      "id": 2,
      "text": "Що таке замикання?",
      "hasOptions": false,
      "answer": "Замикання - це здатність функції запам'ятовувати лексичне оточення, в якому вона була створена, тобто зберігати в собі посилання на це оточення і звертатися до нього.\n\n<a href='https://youtu.be /mI6Jcfsgma4?si=46DV3mXPF6mDTTPs' target='_blank'>Докладніше відео про замикання</a>"    },
    {
      "id": 3,
      "text": "let VS const: чому краще використовувати const, коли це можливо?",
      "hasOptions": false,
      "answer": "Використання const дає дві переваги:\n1) Безпека: оголошення змінних через const захищає від несподіваної зміни значення змінної в коді, що може часто призводить до помилок і несподіваної поведінки програми.\n2) Читання: використання const дозволяє читачеві коду розуміти, що значення змінної не буде змінюватися протягом виконання програми, що робить код більш зрозумілим і зменшує можливість помилок. _blank'>Відео про VAR/LET/CONST</a>"    },
    {
      "id": 4,
      "text": "Що таке проміси (Promises) у JavaScript?",
      "hasOptions": false,
      "answer": "Проміси - це об'єкти, які представляють результат асинхронної операції. Вони можуть перебувати в одному з трьох станів: очікування (pending), виконане (fulfilled) або відхилено (rejected)."    },
    {
      "id": 5,
      "text": "Що таке деструктуризація JavaScript?",
      "hasOptions": false,
      "answer": "Деструктуризація дозволяє вилучати окремі властивості з об'єктів або елементи з масивів і присвоювати їх змінним у зручнішій формі. Наприклад, ось так ми можемо одним рядком вилучити ім'я та адресу користувача з об'єкта user:\n<code>const {name , address} = user;</code>"    },
    {
      "id": 6,
      "text": "Що таке стрілочні функції JavaScript?",
      "hasOptions": false,
      "answer": "Стрілкові функції - це синтаксично компактний спосіб запису функцій у JavaScript, який не має свого власного 'this'. Вони часто використовуються для створення анонімних функцій.\n\n<a href='https://youtu.be /nGVYdna4kq4?si=1k0J9F-MYxWCaq6M' target='_blank'>Детальне відео про функції в JS</a>"    },
    {
      "id": 7,
      "text": "Що таке hoisting у JavaScript?",
      "hasOptions": false,
      "answer": "Hoisting — це механізм JavaScript, при якому змінні та оголошення функцій переміщаються на верх своєї області видимості перед виконанням коду."    },
    {
      "id": 8,
      "text": "Який метод використовується для додавання елемента в масив?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "splice()", "isCorrect": false },
        { "id": 2, "text": "pop()", "isCorrect": false },
        { "id": 3, "text": "shift()", "isCorrect": false },
        { "id": 4, "text": "push()", "isCorrect": true }
      ]
    },
    {
      "id": 9,
      "text": "Який об'єкт представляє поточне вікно браузера?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "document", "isCorrect": false },
        { "id": 2, "text": "screen", "isCorrect": false },
        { "id": 3, "text": "window", "isCorrect": true },
        { "id": 4, "text": "browser", "isCorrect": false }
      ]
    },
    {
      "id": 10,
      "text": "Який оператор використовується для порівняння на строгу рівність?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "==", "isCorrect": false },
        { "id": 2, "text": "===", "isCorrect": true },
        { "id": 3, "text": "=", "isCorrect": false },
        { "id": 4, "text": "!==", "isCorrect": false }
      ]
    },
    {
      "id": 11,
      "text": "Який метод використовується для видалення останнього елемента з масиву?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "splice()", "isCorrect": false },
        { "id": 2, "text": "pop()", "isCorrect": true },
        { "id": 3, "text": "shift()", "isCorrect": false },
        { "id": 4, "text": "push()", "isCorrect": false }
      ]
    },
    {
      "id": 12,
      "text": "Який метод JavaScript використовується для перетворення об'єкта в рядок JSON?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "JSON.stringify()", "isCorrect": true },
        { "id": 2, "text": "JSON.parse()", "isCorrect": false },
        { "id": 3, "text": "JSON.toText()", "isCorrect": false },
        { "id": 4, "text": "JSON.toString()", "isCorrect": false }
      ]
    },
    {
      "id": 13,
      "text": "Який об'єкт у JavaScript використовується для роботи з датою та часом?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Time", "isCorrect": false },
        { "id": 2, "text": "Date", "isCorrect": true },
        { "id": 3, "text": "Calendar", "isCorrect": false },
        { "id": 4, "text": "DateTime", "isCorrect": false }
      ]
    },
    {
      "id": 14,
      "text": "Який метод масиву JavaScript використовується для фільтрації елементів за певним критерієм?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "map()", "isCorrect": false },
        { "id": 2, "text": "filter()", "isCorrect": true },
        { "id": 3, "text": "reduce()", "isCorrect": false },
        { "id": 4, "text": "forEach()", "isCorrect": false }
      ]
    },
    {
      "id": 15,
      "text": "Що таке оператор &&?",
      "hasOptions": false,
      "answer": "Оператор && є логічним оператором 'І' (AND) в багатьох мовах програмування. Він повертає true, якщо обидві умови, які порівнюються, є істинними; в іншому випадку, він повертає false."
    },
    {
      "id": 16,
      "text": "Для чого використовується оператор ||?",
      "hasOptions": false,
      "answer": "Оператор || є логічним оператором 'АБО' (OR) в багатьох мовах програмування. Він повертає true, якщо хоча б одна з умов, які порівнюються, є істинною; в іншому випадку, він повертає false."
    },
    {
      "id": 17,
      "text": "Що таке use strict і як використовується?",
      "hasOptions": false,
      "answer": "use strict є директивою в JavaScript, яка вводить строгий режим виконання коду. В строгому режимі код виконується з більш суворими правилами і відключає деякі неоднозначності та небезпечні функції. Це дозволяє виявляти і виправляти помилки, які можуть залишитися непоміченими в режимі без строгої директиви. Для використання строгого режиму в коді його слід додати на початку файла або функції за допомогою виразу 'use strict';."
    },
    {
      "id": 18,
      "text": "Для чого використовуються оператори break і continue у JavaScript?",
      "hasOptions": false,
      "answer": "Оператор break використовується для припинення виконання циклу або виходу з блоку switch. Він дозволяє вийти з циклу або перервати виконання switch, якщо виконується певна умова. Оператор continue використовується для переходу до наступної ітерації циклу, пропускаючи решту коду в тілі циклу. Він дозволяє пропустити частину коду в циклі для певних умов, не припиняючи виконання всього циклу."
    },
    {
      "id": 19,
      "text": "Навіщо використовується оператор new у JavaScript?",
      "hasOptions": false,
      "answer": "Оператор new у JavaScript використовується для створення нового екземпляра об'єкта. Коли він використовується перед викликом функції-конструктора, він створює новий об'єкт та забезпечує його можливість використання методів та властивостей цього конструктора. Використання оператора new є необхідним для створення екземплярів об'єктів у JavaScript."
    },
    {
      "id": 20,
      "text": "Що таке область видимості (Scope) у JavaScript?",
      "hasOptions": false,
      "answer": "Область видимості (Scope) в JavaScript визначає, де можна отримати доступ до змінних або функцій в коді. В JavaScript існують два типи областей видимості: глобальна та локальна. Глобальна область видимості охоплює весь скрипт, тоді як локальна область видимості знаходиться в межах блоку коду, функції або об'єкта. Змінні, оголошені в глобальній області видимості, доступні всюди, тоді як локальні змінні обмежені своїм контекстом."
    },
    {
      "id": 21,
      "text": "Що таке arguments у JavaScript?",
      "hasOptions": false,
      "answer": "В контексті JavaScript об'єкт arguments є спеціальним об'єктом, який представляється внутрішньою змінною у функціях. Об'єкт arguments містить всі передані аргументи у функцію, навіть якщо їх не було вказано у визові функції. Це дозволяє функціям працювати з будь-якою кількістю переданих аргументів та здійснювати динамічні операції з ними."
    },
    {
      "id": 22,
      "text": "Що таке шаблонні літерали (Template Literals) у JavaScript?",
      "hasOptions": false,
      "answer": "Шаблонні літерали (Template Literals) є нововведенням у синтаксисі JavaScript, яке дозволяє включати в рядок вирази та забезпечує покращену можливість форматування. Вони визначаються за допомогою двох оберток \\` (бектики) та дозволяють вставляти в рядок значення змінних за допомогою ${expression}. Шаблонні літерали забезпечують зручний та читабельний спосіб створення рядків у JavaScript."
    },
    {
      "id": 24,
      "text": "Які способи клонування об'єкта існують в JavaScript?",
      "hasOptions": false,
      "answer": "Існує кілька способів клонування об'єктів у JavaScript:\n1. Використання Object.assign():\n   ```javascript\n   const clonedObject = Object.assign({}, originalObject);\n   ```\n2. Використання оператора spread (...):\n   ```javascript\n   const clonedObject = { ...originalObject };\n   ```\n3. Використання JSON-методів:\n   ```javascript\n   const clonedObject = JSON.parse(JSON.stringify(originalObject));\n   ```\n4. Використання бібліотек, наприклад, lodash:\n   ```javascript\n   const clonedObject = _.cloneDeep(originalObject);\n   ```"
    },
    {
      "id": 25,
      "text": "Чим клас відрізняється від об'єкта в JavaScript?",
      "hasOptions": false,
      "answer": "У JavaScript клас є спеціальною конструкцією для створення об'єктів та визначення їх структури та поведінки. Класи використовуються для створення екземплярів об'єктів, в той час як об'єкт - це конкретний екземпляр стандартного об'єктного типу в JavaScript. Класи надають можливість використовувати конструктори, методи та успадкування для створення об'єктів з певними характеристиками та функціональністю."
    },
    {
      "id": 26,
      "text": "Як визначити, чи заморожено об'єкт в JavaScript?",
      "hasOptions": false,
      "answer": "В JavaScript можна використовувати метод Object.isFrozen() для визначення, чи об'єкт є замороженим. Наприклад:\n```javascript\nconst isFrozen = Object.isFrozen(myObject);\n```"
    },
    {
      "id": 27,
      "text": "Як перевірити, чи є число кінцевим (finite) в JavaScript?",
      "hasOptions": false,
      "answer": "У JavaScript можна використовувати глобальні методи isFinite() або Number.isFinite() для перевірки, чи число є кінцевим. Наприклад:\n```javascript\nconst isFiniteNumber = isFinite(myNumber);\nconst isFiniteNumberV2 = Number.isFinite(myNumber);\n```"
    },
    {
      "id": 28,
      "text": "Що робить метод eval() в JavaScript?",
      "hasOptions": false,
      "answer": "Метод eval() використовується для виконання строкового представлення коду як JavaScript-коду. Він виконує переданий рядок як код програми, що може викликати виконання дій та повертати результат. Використання методу eval() повинно бути обережним, оскільки воно може створити безпекові проблеми та зробити код важким для розуміння та обслуговування."
    },
    {
      "id": 29,
      "text": "Як перевірити, що змінна дорівнює NaN в JavaScript?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "if (myVariable === NaN)", "isCorrect": false },
        { "id": 2, "text": "if (isNaN(myVariable))", "isCorrect": true },
        { "id": 3, "text": "if (myVariable == NaN)", "isCorrect": false },
        { "id": 4, "text": "if (myVariable === 'NaN')", "isCorrect": false }
      ]
    },
    {
      "id": 30,
      "text": "Що таке NaN в JavaScript?",
      "hasOptions": false,
      "answer": "NaN означає 'Not-a-Number' і є спеціальним значенням в JavaScript, що вказує на те, що операція повернула нечисловий результат. Наприклад, ділення на нуль або спроба конвертації нечислового рядка в число може призвести до отримання NaN."
    },
    {
      "id": 31,
      "text": "Опишіть методи для перевірки наявності підрядка у рядку в JavaScript.",
      "hasOptions": false,
      "answer": "1. Метод includes(): Повертає true, якщо рядок містить підрядок, і false - в іншому випадку.\n\n2. Метод indexOf(): Повертає індекс першого входження підрядка у рядок, якщо такий підрядок існує, і -1, якщо він відсутній.\n\n3. Метод search(): Повертає індекс першого входження вказаного регулярного виразу у рядок, якщо співпадіння є, і -1, якщо співпадіння відсутнє.\n\n4. Метод match(): Повертає масив зі всіма збігами вказаного регулярного виразу у рядку, якщо вони є, і null, якщо співпадінь відсутні.\n\n5. Метод test(): Перевіряє, чи відповідає рядок вказаному регулярному виразу, і повертає true або false.\n\n6. Метод matchAll(): Повертає об'єкт ітератора, який містить всі збіги вказаного регулярного виразу у рядку.\n\n7. Метод startsWith(): Повертає true, якщо рядок починається з вказаного підрядка, і false - в іншому випадку.\n\n8. Метод endsWith(): Повертає true, якщо рядок закінчується вказаним підрядком, і false - в іншому випадку.\n\n9. Метод lastIndexOf(): Повертає індекс останнього входження підрядка у рядок, якщо такий підрядок існує, і -1, якщо він відсутній."
    },
    {
      "id": 32,
      "text": "Що таке тимчасова мертва зона?",
      "hasOptions": false,
      "answer": "Тимчасова мертва зона - це ситуація, коли розробник розміщує руку на клавіатурі для початку нового діапазону введення, але відразу ж стається помилковий вивід введених символів. Це може трапитися через неправильне розташування руки або недостатній досвід користувача з конкретною клавіатурою. Тимчасова мертва зона може виникнути при швидкому введенні тексту і призводить до неправильного виведення символів або навіть втрати деяких символів."
    },
    {
      "id": 33,
      "text": "Що таке типи посилань?",
      "hasOptions": false,
      "answer": "Типи посилань визначають спосіб, яким браузер взаємодіє з веб-ресурсом. Є три основних типи посилань: абсолютні, відносини та кореневі. \n1. Абсолютні посилання вказують повний шлях до ресурсу, включаючи протокол, домен та шлях.\n2. Відносини посилання вказують шлях до ресурсу відносно поточного розташування.\n3. Кореневі посилання починаються з кореня домена та вказують шлях відносно кореня."
    },
    {
      "id": 34,
      "text": "У яких випадках застосовуються анонімні функції?",
      "hasOptions": false,
      "answer": "Анонімні функції використовуються в разі, коли потрібно створити функцію без прив'язки до конкретної імені, або коли потрібно передати функцію як аргумент в іншу функцію. Вони часто застосовуються при оголошенні функцій-колбеків, в обробниках подій, асинхронних операціях або при визначенні функцій на льоту."
    },
    {
      "id": 35,
      "text": "Що повертає promise?",
      "hasOptions": false,
      "answer": "Promise повертає об'єкт, який представляє результат або помилку асинхронної операції. Цей об'єкт може мати три стани: pending (в очікуванні), fulfilled (виконаний) або rejected (відхилений). У випадку виконання або відхилення операції, Promise викликає відповідний колбек (resolve або reject) і передає результат або помилку обробнику, призначеному за допомогою методів then або catch."
    },
    {
      "id": 36,
      "text": "У чому різниця між атрибутами та властивостями?",
      "hasOptions": false,
      "answer": "Атрибути та властивості відрізняються в контексті HTML та JavaScript. \n1. Атрибути - це частини тегів HTML, які визначають додаткові характеристики елементів, але не зберігаються в об'єкті елемента в JavaScript. \n2. Властивості - це характеристики об'єктів JavaScript, включаючи DOM-елементи. Властивості представляють собою інтерфейс для отримання чи встановлення характеристик об'єктів."
    },
    {
      "id": 37,
      "text": "Що таке файли cookie у JavaScript?",
      "hasOptions": false,
      "answer": "Файли cookie - це невеликі файли, які зберігаються на комп'ютері користувача і містять інформацію про відвідані веб-сайти. Вони використовуються для збереження деяких даних на стороні клієнта, таких як ідентифікатор сеансу, налаштування інтерфейсу чи інші дані, щоб забезпечити персоналізований досвід користувача та здійснити відстеження користувачів."
    },
    {
      "id": 38,
      "text": "Яка різниця між параметрами та аргументами?",
      "hasOptions": false,
      "answer": "У контексті програмування терміни 'параметри' та 'аргументи' використовуються відповідно до визначення функцій. \n1. Параметри - це змінні, оголошені у визначенні функції, які приймають значення при її виклику.\n2. Аргументи - це конкретні значення, передані у функцію під час її виклику, і які приймаються параметрами функції для виконання обчислень або дій."
    },
    {
      "id": 39,
      "text": "Що таке модулі (Modules)?",
      "hasOptions": false,
      "answer": "Модулі - це механізм організації коду в програмуванні, який дозволяє розділити програму на окремі незалежні частини з метою полегшення розробки, підтримки та використання коду. Вони дозволяють ізолювати логіку, змінні та функції, щоб не впливати на решту програми і забезпечити більшу модульність та перевикористовуваність коду."
    },
    {
      "id": 40,
      "text": "Що таке об'єкт Set?",
      "hasOptions": false,
      "answer": "Об'єкт Set є вбудованим об'єктом у JavaScript і представляє собою колекцію унікальних значень, тобто значень, які не повторюються. Він дозволяє зберігати будь-який тип значень, і кожне значення в ньому має бути унікальним. Об'єкт Set використовується для вирішення задач, де важливо зберігати лише унікальні елементи та не важливий їх порядок."
    },
    {
      "id": 41,
      "text": "Що таке параметри за замовчуванням (Default Parameters)?",
      "hasOptions": false,
      "answer": "Параметри за замовчуванням - це механізм у JavaScript, який дозволяє встановлювати значення за замовчуванням для параметрів функції. Якщо значення не передається при виклику функції або передається як undefined, то буде використано значення, вказане за замовчуванням. Це спрощує роботу з функціями, дозволяючи задавати значення за замовчуванням для аргументів, які можуть бути опущені."
    },
    {
      "id": 42,
      "text": "Що таке об'єктна обгортка (Wrapper Objects)?",
      "hasOptions": false,
      "answer": "Об'єктні обгортки (Wrapper Objects) у JavaScript є об'єктами, які надають об'єктний інтерфейс для примітивних типів даних (наприклад, чисел, рядків та булевих значень). Кожен примітивний тип даних має свій відповідний об'єкт-обгортку: Number для чисел, String для рядків та Boolean для булевих значень. Об'єктні обгортки роблять можливим використання методів та властивостей об'єктів для примітивних значень."
    },
    {
      "id": 43,
      "text": "Що таке XSS?",
      "hasOptions": false,
      "answer": "XSS (Cross-Site Scripting) - це атака на безпеку веб-додатків, при якій зловмисник вставляє в веб-сторінку вредливий скрипт. Цей скрипт може виконатися в браузері користувача, який переглядає сторінку, і використовувати його авторизаційні дані або взаємодіяти з веб-сайтом в його контексті. XSS може бути виконаний як в stored (збережений), так і в reflected (відображений) формах, та представляє серйозну загрозу для безпеки інтернет-ресурсів."
    },
    {
      "id": 44,
      "text": "Навіщо використовується WeakSet?",
      "hasOptions": false,
      "answer": "WeakSet - це об'єкт в JavaScript, що дозволяє зберігати тільки об'єкти у вигляді слабких посилань. Основна відмінність WeakSet від Set полягає в тому, що в WeakSet елементи мають слабкі посилання, тобто вони не утримують об'єкти в пам'яті, якщо на них немає сильних посилань з інших частин програми. Це може бути корисно в ситуаціях, коли вам не потрібно завтримувати життєвий цикл об'єктів у пам'яті, і вони можуть бути видалені з WeakSet автоматично, якщо на них немає ссилок."
    },
    {
      "id": 45,
      "text": "У чому різниця між Set та WeakSet?",
      "hasOptions": false,
      "answer": "Основна різниця між Set та WeakSet полягає в тому, як вони обробляють посилання на об'єкти. Set утримує сильні посилання на свої елементи, що означає, що якщо існуючий об'єкт утримує посилання на елемент Set, то він буде утримувати його в пам'яті, навіть якщо інших посилань на нього немає. У випадку WeakSet елементи утримуються через слабкі посилання. Якщо на елемент немає інших сильних посилань, він може бути видалений автоматично системою збору сміття, навіть якщо він є частиною WeakSet."
    },
    {
      "id": 46,
      "text": "Які методи доступні у WeakSet?",
      "hasOptions": false,
      "answer": "WeakSet має лише кілька методів, оскільки він спрощений і призначений для простого використання слабких посилань на об'єкти. Декілька з основних методів WeakSet:\n1. **add(value)**: Додає новий елемент у WeakSet.\n2. **delete(value)**: Видаляє елемент із WeakSet.\n3. **has(value)**: Перевіряє, чи існує заданий елемент у WeakSet."
    },
    {
      "id": 47,
      "text": "Навіщо використовується WeakMap?",
      "hasOptions": false,
      "answer": "WeakMap - це тип об'єкта в JavaScript, який дозволяє використовувати об'єкти в якості ключів у колекції, але з слабкими посиланнями. Головна його особливість - в тому, що він не утримує об'єкти в пам'яті, якщо немає інших посилань на цей об'єкт поза WeakMap. Це може бути важливо в деяких випадках для управління пам'яттю та уникнення утечок пам'яті."
    },
    {
      "id": 48,
      "text": "У чому різниця між Map та WeakMap?",
      "hasOptions": false,
      "answer": "Основна різниця між Map і WeakMap полягає в тому, що Map зберігає сильні посилання на ключі, тоді як WeakMap використовує слабкі посилання на ключі. Це означає, що якщо інші посилання на об'єкт відсутні поза WeakMap, то цей об'єкт може бути видалений з WeakMap і пам'ять може бути виведена. Map, навпаки, буде утримувати посилання на ключі, навіть якщо вони в інших частинах коду вже не використовуються."
    },
    {
      "id": 49,
      "text": "Які методи доступні у WeakMap?",
      "hasOptions": false,
      "answer": "WeakMap володіє обмеженим функціоналом порівняно з Map. Основні методи WeakMap включають:\n1. set(key, value): Додає новий елемент в WeakMap.\n2. get(key): Повертає значення, пов'язане з ключем в WeakMap.\n3. has(key): Перевіряє наявність ключа в WeakMap.\n4. delete(key): Видаляє пару ключ-значення за ключем в WeakMap."
    },
    {
      "id": 50,
      "text": "Що таке рекурсія?",
      "hasOptions": false,
      "answer": "Рекурсія - це процес, коли функція викликає сама себе. У рекурсивному виклику функція розв'язує задачу шляхом розбиття її на більш прості підзадачі того ж типу. Рекурсія є потужним інструментом у програмуванні, особливо при роботі з завданнями, які мають структуру, подібну до самого себе."
    },
    {
      "id": 51,
      "text": "Навіщо використовується метод seal()?",
      "hasOptions": false,
      "answer": "Метод `seal()` використовується для запобігання додавання нових властивостей до об'єкта, а також для встановлення атрибута `configurable` в `false` для всіх існуючих властивостей об'єкта. Об'єкт, який був 'запечатаний', не може бути динамічно змінений у відсутність зняття запечатування."
    },
    {
      "id": 52,
      "text": "Що таке ціль події чи цільовий елемент (event.target)?",
      "hasOptions": false,
      "answer": "Ціль події або цільовий елемент (event.target) - це елемент, на якому виникла подія. Властивість `target` об'єкта події містить посилання на елемент, який є джерелом події. Наприклад, при кліці на кнопку, ціль події буде вказувати на саму кнопку."
    },
    {
      "id": 53,
      "text": "Що таке поточна мета події (event.currentTarget)?",
      "hasOptions": false,
      "answer": "Поточна мета події (event.currentTarget) - це елемент, який обробляє подію в данний момент часу. Відмінність між `event.currentTarget` та `event.target` полягає в тому, що `currentTarget` завжди буде посилатися на елемент, на якому призначений обробник подій, тоді як `target` вказує на конкретний елемент, на якому виникла подія."
    },
    {
      "id": 55,
      "text": "Що спільного між null та undefined?",
      "hasOptions": false,
      "answer": "null та undefined в JavaScript є примітивними значеннями, які вказують на відсутність значення. Вони використовуються, коли змінні або властивості не мають значення або коли значення не було присвоєно. null вказує на відсутність значення або на спеціальний випадок відсутності об'єкта, тоді як undefined вказує на те, що значення не було присвоєно змінній."
    },
    {
      "id": 56,
      "text": "У чому різниця між undefined та is not defined?",
      "hasOptions": false,
      "answer": "undefined та is not defined - це різні речі в контексті JavaScript. undefined є спеціальним значенням, яке вказує на те, що змінна або властивість не має значення. З іншого боку, is not defined вказує на те, що ідентифікатор (змінна, функція тощо) не був оголошений або недоступний у даному контексті коду. Така помилка зазвичай виникає при спробі використання ідентифікатора, який не існує."
    },
    {
      "id": 57,
      "text": "Розкажіть коротко про Symbol? з прикладом",
      "hasOptions": false,
      "answer": "Symbol - це примітивний тип даних в JavaScript, який представляє собою унікальний ідентифікатор. Кожен створений символ є унікальним, і вони можуть використовуватися як ключі для властивостей об'єктів. Символи не є властивостями, але скоріше індексами, і не впливають на ітерацію об'єктів. Створення символу виглядає так: const mySymbol = Symbol('Опис');, де 'Опис' - необов'язковий рядок, що вказує на опис символу."
    },
    {
      "id": 58,
      "text": "Що таке JSON?",
      "hasOptions": false,
      "answer": "JSON (JavaScript Object Notation) - це легкий формат обміну даними, який є текстовим та незалежним від мови програмування. Він базується на синтаксисі мови JavaScript та використовується для представлення структури даних у вигляді об'єктів та масивів. JSON використовується для передачі даних між сервером і клієнтом, а також для зберігання та обміну конфігураційних даних."
    },
    {
      "id": 59,
      "text": "Методи перетворення простих примітивних типів даних в число?",
      "hasOptions": false,
      "answer": "У JavaScript існують різні методи для перетворення простих примітивних типів даних в число:\n1. parseInt(): Перетворює рядок в ціле число. Наприклад, parseInt('10') поверне 10.\n2. parseFloat(): Перетворює рядок в число з плаваючою точкою. Наприклад, parseFloat('10.5') поверне 10.5.\n3. Number(): Перетворює значення в число. Наприклад, Number('10') поверне 10.\n4. Unary plus (+): Використовується як унарний оператор для перетворення значень в число. Наприклад, + '10' поверне 10."
    },
    {
      "id": 60,
      "text": "Як можна клонувати масив?",
      "hasOptions": false,
      "answer": "У JavaScript є кілька способів клонування масиву:\n1. Використання методу slice(): Метод slice() створює копію частини або всього масиву. Наприклад, const newArray = oldArray.slice();\n2. Використання методу concat(): Метод concat() додає один або декілька масивів до іншого масиву, створюючи новий. Наприклад, const newArray = [].concat(oldArray);\n3. Використання оператора spread (...): Оператор spread розгортає елементи масиву в новому масиві. Наприклад, const newArray = [...oldArray];\n4. Використання методу Array.from(): Метод Array.from() створює новий масив з ітерованого об'єкта, такого як масив. Наприклад, const newArray = Array.from(oldArray);"
    },
    {
      "id": 61,
      "text": "Як перевірити, чи є об'єкт масивом?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "isArray(myObject)", "isCorrect": false },
        { "id": 2, "text": "checkArray(myObject)", "isCorrect": false },
        { "id": 3, "text": "Array.isArray(myObject)", "isCorrect": true },
        { "id": 4, "text": "isType(myObject, 'array')", "isCorrect": false }
      ]
    },
    {
      "id": 62,
      "text": "Як можна додати елемент на початок і в кінець масиву?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "pushElement(), unshiftElement()", "isCorrect": false },
        { "id": 2, "text": "prependElement(), appendElement()", "isCorrect": false },
        { "id": 3, "text": "addToStart(), addToEnd()", "isCorrect": false },
        { "id": 4, "text": "unshift(), push()", "isCorrect": true }
      ]
    },
    {
      "id": 63,
      "text": "Як знайти перетин двох масивів в JavaScript?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "intersection(arr1, arr2)", "isCorrect": false },
        { "id": 2, "text": "arr1.intersect(arr2)", "isCorrect": false },
        { "id": 3, "text": "arr1.filter(value => arr2.includes(value))", "isCorrect": true },
        { "id": 4, "text": "arr1.combine(arr2)", "isCorrect": false }
      ]
    },
    {
      "id": 64,
      "text": "Як можна викликати методи масиву на об'єкті arguments через call, apply?",
      "hasOptions": true,
      "options": [
        {
          "id": 1,
          "text": "Array.call(arguments, myArrayMethod)",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "myArrayMethod.call(Array.prototype.slice.call(arguments))",
          "isCorrect": true
        },
        {
          "id": 3,
          "text": "Array.apply(arguments, myArrayMethod)",
          "isCorrect": false
        },
        {
          "id": 4,
          "text": "myArrayMethod.apply(Array.prototype.slice.call(arguments))",
          "isCorrect": true
        }
      ]
    },
    {
      "id": 65,
      "text": "Як можна викликати методи масиву на об'єкті arguments через call, apply?",
      "hasOptions": false,
      "answer": "Методи масиву можна викликати на об'єкті arguments за допомогою call або apply, як показано в прикладі: myArrayMethod.call(Array.prototype.slice.call(arguments))"
    },
    {
      "id": 66,
      "text": "Як би ви реалізували метод Array.prototype.map?",
      "hasOptions": false,
      "answer": "Array.prototype.myMap = function(callback, thisArg) {\n  const result = [];\n  const array = this;\n\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      result[i] = callback.call(thisArg, array[i], i, array);\n    }\n  }\n\n  return result;\n};"
    },
    {
      "id": 67,
      "text": "Як би ви реалізували метод Array.prototype.filter?",
      "hasOptions": false,
      "answer": "Array.prototype.myFilter = function(callback, thisArg) {\n  const result = [];\n  const array = this;\n\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      const element = array[i];\n      if (callback.call(thisArg, element, i, array)) {\n        result.push(element);\n      }\n    }\n  }\n\n  return result;\n};"
    },
    {
      "id": 68,
      "text": "Як би ви реалізували метод Array.prototype.reduce?",
      "hasOptions": false,
      "answer": "Array.prototype.myReduce = function(callback, initialValue) {\n  const array = this;\n  let accumulator = initialValue === undefined ? undefined : initialValue;\n\n  for (let i = 0; i < array.length; i++) {\n    if (i in array) {\n      const element = array[i];\n      if (accumulator === undefined) {\n        accumulator = element;\n      } else {\n        accumulator = callback.call(undefined, accumulator, element, i, array);\n      }\n    }\n  }\n\n  if (accumulator === undefined) {\n    throw new TypeError('Reduce of empty array with no initial value');\n  }\n\n  return accumulator;\n};"
    },
    {
      "id": 69,
      "text": "Що таке IIFE або Immediately Invoked Function Expression?",
      "hasOptions": false,
      "answer": "IIFE або Immediately Invoked Function Expression - це функція в JavaScript, яка визивається (виконується) одразу після свого створення. Це досягається шляхом обгортання функції у пару круглих дужок та миттєвого виклику через другу пару круглих дужок, наприклад (function() { /* код */ })()."
    },
    {
      "id": 70,
      "text": "Що таке функції найвищого порядку (Higher Order Functions)?",
      "hasOptions": false,
      "answer": "Функції найвищого порядку - це функції, які приймають інші функції як аргументи або повертають функції як результат. Це концепція функціонального програмування, яка дозволяє створювати більш загальні та пере використовувані функції."
    },
    {
      "id": 71,
      "text": "У чому різниця між function expression та function declaration?",
      "hasOptions": false,
      "answer": "Function declaration - це спосіб створення функції, коли вона оголошується в основному потоці коду. Function expression - це коли функцію присвоюють змінній або використовують як значення виразу, зазвичай після її оголошення. Основна різниця полягає в тому, що function declarations можна викликати перед їхнім оголошенням (hoisting), а function expressions - ні."
    },
    {
      "id": 72,
      "text": "У чому різниця між class і function constructor?",
      "hasOptions": false,
      "answer": "Class - це синтаксичний цукор (syntactic sugar) над функцією-конструктором. Вони обидві використовуються для створення об'єктів. Class надає більш зручний та читабельний синтаксис для створення об'єктів та використання наслідування, в той час як function constructor - це більш старий підхід, який також дозволяє створювати об'єкти, але використовує функцію для цього."
    },
    {
      "id": 73,
      "text": "Як використовується метод Function.prototype.apply?",
      "hasOptions": false,
      "answer": "Метод apply використовується для виклику функції з вказаним контекстом (this) та масивом аргументів. Він приймає два параметри: об'єкт, який буде використовуватися як this у функції, і масив аргументів, які будуть передані у функцію. Синтаксис: `function.apply(context, [arg1, arg2, ...])`."
    },
    {
      "id": 74,
      "text": "Як використовується метод Function.prototype.call?",
      "hasOptions": false,
      "answer": "Метод call використовується для виклику функції з вказаним контекстом (this) та передачею окремих аргументів. Він приймає перший параметр як об'єкт, який буде використовуватися як this у функції, а решта параметрів будуть передані як аргументи у функцію. Синтаксис: `function.call(context, arg1, arg2, ...)`. "
    },
    {
      "id": 75,
      "text": "Як використовується метод Function.prototype.bind?",
      "hasOptions": false,
      "answer": "Метод bind використовується для створення нової функції, яка буде мати певний контекст (this) та, опціонально, певний набір аргументів. Він не викликає функцію безпосередньо, але повертає нову функцію, яку можна викликати пізніше. Синтаксис: `function.bind(context, arg1, arg2, ...)`. "
    },
    {
      "id": 76,
      "text": "Що таке `this`?",
      "hasOptions": false,
      "answer": "`this` - це спеціальний об'єкт, який вказує на контекст виклику функції. Значення `this` може змінюватися в залежності від того, як функція була викликана. У глобальному контексті `this` вказує на об'єкт `window` (в браузерах). У функціях-методах `this` вказує на об'єкт, до якого вони відносяться. У функціях, викликаних як конструктори за допомогою `new`, `this` вказує на новостворений об'єкт. Для стрілкових функцій `this` вказує на `this` у контексті, в якому функція була створена, і не змінюється при виклику."
    },
    {
      "id": 77,
      "text": "Що таке функція зворотного виклику (Callback Function)?",
      "hasOptions": false,
      "answer": "Функція зворотного виклику (Callback Function) - це функція, яка передається як аргумент в іншу функцію і викликається під час виконання першої функції. Callback-функції використовуються, зазвичай, для визначення реакції на події, обробки даних асинхронних операцій чи для подальшого виконання певних дій."
    },
    {
      "id": 78,
      "text": "Що таке замикання (Closures)?",
      "hasOptions": false,
      "answer": "Замикання (Closures) - це механізм в JavaScript, який дозволяє функції зберігати доступ до змінних свого зовнішнього контексту (лексичного оточення) після того, як вони завершили виконання. Замикання дозволяють створювати і утримувати приватні дані, а також реалізовувати інші конструкції, такі як функції зворотного виклику (callbacks) та каррінг (currying)."
    },
    {
      "id": 79,
      "text": "Навіщо потрібна функція fetch?",
      "hasOptions": false,
      "answer": "Функція `fetch` використовується для виконання запитів на сервер і отримання ресурсів, таких як дані чи файли, з веб-серверів. Це стандарт для взаємодії з HTTP-запитами у сучасних веб-додатках. Функція `fetch` повертає Promise, що дозволяє вам асинхронно обробляти результат запиту, отримувати і обробляти дані, які повертає сервер."
    },
    {
      "id": 80,
      "text": "Як організувати інкапсуляцію через замикання?",
      "hasOptions": false,
      "answer": "Інкапсуляція через замикання (closure) полягає в використанні функцій для створення приватних областей видимості та управління доступом до даних. Внутрішній блок коду має доступ до змінних зовнішньої функції, але зовнішній світ не має прямого доступу до цих змінних. Такий підхід дозволяє приховати дані від зовнішнього втручання та забезпечити контроль над доступом до них."
    },
    {
      "id": 81,
      "text": "У чому різниця між звичайною функцією та функціональним виразом?",
      "hasOptions": false,
      "answer": "Основна різниця між звичайною функцією та функціональним виразом полягає в тому, як вони оголошуються та піднімаються в контексті виконання коду. Звичайні функції можуть оголошуватися заздалегідь (перед виконанням коду), і вони піднімаються (hoisting), що дозволяє викликати їх до оголошення. Функціональні вирази оголошуються тільки в тому місці, де вони записані у коді, і не піднімаються. Вони частіше використовуються для присвоєння анонімних функцій змінним."
    },
    {
      "id": 82,
      "text": "Що таке Arrow Functions?",
      "hasOptions": false,
      "answer": "Arrow Functions - це новий синтаксис для оголошення функцій в JavaScript, який був введений в стандарті ECMAScript 6 (ES6). Вони надають коротший та зручніший спосіб написання функцій порівняно зі звичайними функціями. Основна особливість Arrow Functions полягає в тому, що вони не власні this, arguments, super або new.target, вони використовують контекст, в якому були створені."
    },
    {
      "id": 83,
      "text": "Що таке поширення події (Event Propagation)?",
      "hasOptions": false,
      "answer": "Поширення події - це механізм визначення того, як подія рухається від кореня DOM-дерева до вузла, який викликав подію, або в інший напрямок (від вузла до кореня). Є три фази поширення подій: захоплення (capture), цільова (target), та всплиття (bubbling). У фазі захоплення подія спускається вниз від кореня до цільового вузла. У фазі цільової подія досягає цільового вузла, а потім, у фазі всплиття, подія піднімається назад вгору."
    },
    {
      "id": 84,
      "text": "Що таке спливання події (Event Bubbling)?",
      "hasOptions": false,
      "answer": "Спливання події (Event Bubbling) - це фаза поширення події, коли подія піднімається вгору від цільового вузла до кореня DOM-дерева. У цій фазі подія спочатку досягає цільового вузла, а потім піднімається вгору через батьківські вузли, передаваючи можливість кожному батьківському вузлу обробити подію."
    },
    {
      "id": 85,
      "text": "Що таке занурення події (Event Capturing)?",
      "hasOptions": false,
      "answer": "Занурення події (Event Capturing) - це фаза поширення події, коли подія спускається з кореня DOM-дерева до цільового вузла. У цій фазі подія спочатку досягає кореня, а потім спускається вниз по ієрархії вузлів до цільового вузла, дозволяючи кожному вузлу на шляху обробити подію."
    },
    {
      "id": 86,
      "text": "У чому різниця між методами event.preventDefault() та event.stopPropagation()?",
      "hasOptions": false,
      "answer": "Метод event.preventDefault() використовується для відміни стандартної дії, яку виконує браузер при виникненні певної події, наприклад, при натисканні на кнопку або відправці форми. З іншого боку, метод event.stopPropagation() зупиняє подальше спливання або занурення події вверх або вниз по DOM-дереву. Він використовується для того, щоб зупинити поширення події на інші елементи, але не впливає на саму дію, яку викликала подія."
    },
    {
      "id": 87,
      "text": "Як дізнатися про використання методу event.preventDefault()?",
      "hasOptions": false,
      "answer": "Метод event.preventDefault() можна використовувати для того, щоб відмінити стандартну дію, яка виникає при певній події. Щоб дізнатися, чи був використаний цей метод в обробнику подій, можна перевірити властивість event.defaultPrevented. Якщо ця властивість має значення true, це означає, що метод event.preventDefault() був використаний, і стандартна дія була скасована."
    },
    {
      "id": 88,
      "text": "Як визначити, чи є об'єкт пустим?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Використовуючи метод isEmptyObject(obj)", "isCorrect": false },
        { "id": 2, "text": "За допомогою Object.keys(obj).length === 0", "isCorrect": true },
        { "id": 3, "text": "Перевірка на null", "isCorrect": false },
        { "id": 4, "text": "За допомогою obj.emptyCheck()", "isCorrect": false }
      ]
    },
    {
      "id": 89,
      "text": "Як глибоко скопіювати об'єкт в JavaScript (не поверхнево)?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Використовуючи метод Object.copy(obj)", "isCorrect": false },
        { "id": 2, "text": "За допомогою JSON.stringify та JSON.parse", "isCorrect": true },
        { "id": 3, "text": "Використовуючи метод obj.clone()", "isCorrect": false },
        { "id": 4, "text": "Використовуючи об'єктний оператор {...obj}", "isCorrect": false }
      ]
    },
    {
      "id": 90,
      "text": "Як перевірити наявність властивості в об'єкті, включаючи всі вкладені об'єкти?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "За допомогою оператора in", "isCorrect": false },
        { "id": 2, "text": "За допомогою методу hasOwnProperty()", "isCorrect": true },
        { "id": 3, "text": "За допомогою методу propertyExists()", "isCorrect": false },
        { "id": 4, "text": "За допомогою функції checkProperty()", "isCorrect": false }
      ]
    },

    {
      "id": 91,
      "text": "Як правильно порівняти два об'єкта на рівність?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Використати оператор ==", "isCorrect": false },
        { "id": 2, "text": "Використати оператор ===", "isCorrect": false },
        { "id": 3, "text": "Використати метод isEqual()", "isCorrect": false },
        { "id": 4, "text": "Використати бібліотеку, наприклад, Lodash і метод _.isEqual() чи JSON.stringify(ob1) === JSON.stringify(ob2)", "isCorrect": true }
      ]
    },

    {
      "id": 92,
      "text": "Як можна визначити довжину об'єкта?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Використати властивість length", "isCorrect": false },
        { "id": 2, "text": "Використати метод size()", "isCorrect": false },
        { "id": 3, "text": "Використати метод length()", "isCorrect": false },
        { "id": 4, "text": "Використати метод Object.keys(obj).length", "isCorrect": true }
      ]
    },
    {
      "id": 93,
      "text": "Як можна видалити 'фолсі' значення з масиву в JavaScript?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Використати метод removeFalseValues()", "isCorrect": false },
        { "id": 2, "text": "Використати const filtered = arr.filter(Boolean)", "isCorrect": true },
        { "id": 3, "text": "Використати метод deleteFalseValues()", "isCorrect": false },
        { "id": 4, "text": "Використати функцію purgeFalseValues()", "isCorrect": false }
      ]
    },
    {
      "id": 94,
      "text": "Як можна видалити дублікати з масиву в JavaScript?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Використати метод unique()", "isCorrect": false },
        { "id": 2, "text": "Використати метод removeDuplicates()", "isCorrect": false },
        { "id": 3, "text": "Використати метод distinct()", "isCorrect": false },
        { "id": 4, "text": "Використати arr.filter((value, index, self) => self.indexOf(value) === index) або [... new Set(arr)]", "isCorrect": true }
      ]
    }
  ],
  "react": [
    {
      "id": 1,
      "text": "Що таке React JS?",
      "hasOptions": false,
      "answer": "React JS, або просто React, це відкрита бібліотека JavaScript для створення інтерфейсів користувача, особливо для односторінкових додатків (SPA). Ключові особливості React:\n1) Компонентний підхід: React будується на концепції компонентів, що дозволяє розробникам створювати легко шматки коду, що перевикористовуються;\n2) Віртуальний DOM: React використовує віртуальний DOM для відстеження змін Це абстракція реального DOM, що дозволяє бібліотеці оновлювати тільки ті частини інтерфейсу, які дійсно змінилися, замість повного перерендерингу сторінки. Це робить React відносно швидким;\n3) Хуки: Введення хуків дозволило використовувати стани та інші можливості класових компонентів у функціональних компонентах, що зробило код коротшим і чистішим; полегшує розробку складних програм.\n\nДокладніше: <a href='https://youtu.be/R_39q-vdOaE?si=mEKDaYDjEdnojG-N' target='_blank'>Введення в React (відео)</a>"    },
    {
      "id": 2,
      "text": "Для чого потрібний атрибут key при рендері списків?",
      "hasOptions": false,
      "answer": "Ключі (keys) допомагають React визначати, які елементи були змінені, додані або видалені. Їх необхідно вказувати, щоб React міг зіставляти елементи масиву з часом. Кращий спосіб вибрати ключ - це використовувати рядок, який явно відрізнятиме елемент списку від його сусідів. Найкраще ви будете використовувати ID з ваших даних як ключі. Індекси масиву теж можна використовувати для цього, але тільки якщо елементи масиву не додаються на початок, не переставляються і не видаляються."    },
    {
      "id": 3,
      "text": "Як працює проп children?",
      "hasOptions": false,
      "answer": "Деякі компоненти не знають своїх нащадків заздалегідь. Це особливо характерно для таких компонентів, як Sidebar або Dialog, які являють собою як би «коробку», в яку можна щось покласти. Для таких компонентів можна використовувати спеціальний проп. children, який передасть дочірні елементи відразу на висновок.\n\nДокладніше: <a href='https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children' target= '_blank'>Документація React (eng)</a>"    },
    {
      "id": 4,
      "text": "Що таке портали у React?",
      "hasOptions": false,
      "answer": "Портали дозволяють рендерувати дочірні елементи в DOM-вузол, який знаходиться поза DOM-ієрархією батьківського компонента. Типовий випадок застосування порталів - коли в батьківському компоненті задані стилі overflow: hidden або z-index, але вам потрібно, щоб дочірній елемент візуально виходив за рамки свого контейнера, найчастіше це діалогові вікна, спливаючі картки та підказки."    },
    {
      "id": 5,
      "text": "Що таке Reconciliation (Звірка)?",
      "hasOptions": false,
      "answer": "Це процес, за допомогою якого React оновлює DOM. Коли стан компонента змінюється, React повинен розрахувати необхідність оновлення DOM. Це робиться шляхом створення віртуального DOM і порівняння його з поточним DOM. У цьому контексті віртуальний DOM міститиме новий стан компонента. "    },
    {
      "id": 6,
      "text": "Для чого використовується хук useEffect в React?",
      "hasOptions": true,
      "options": [
        {
          "id": 1,
          "text": "Зберігання стану компонента",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Виконання побічних ефектів",
          "isCorrect": true
        },
        { "id": 3, "text": "Мемоізації значень", "isCorrect": false },
        {
          "id": 4,
          "text": "Створення посилань на елементи DOM",
          "isCorrect": false
        }
      ]
    },
    {
      "id": 7,
      "text": "Що буде, якщо другим аргументом в useEffect передати порожній масив []?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Помилка", "isCorrect": false },
        {
          "id": 2,
          "text": "useEffect буде запущений 0 раз",
          "isCorrect": false
        },
        { "id": 3, "text": "useEffect буде запущений 1 раз", "isCorrect": true },
        { "id": 4, "text": "Немає правильної відповіді", "isCorrect": false }
      ]
    },
    {
      "id": 8,
      "text": "Який хук використовується для створення стану у компоненті?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "useEffect", "isCorrect": false },
        { "id": 2, "text": "useState", "isCorrect": true },
        { "id": 3, "text": "useContext", "isCorrect": false },
        { "id": 4, "text": "useReducer", "isCorrect": false }
      ]
    },
    {
      "id": 9,
      "text": "Який елемент використовується для групування елементів без додавання додаткових вузлів у DOM?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "<Group>", "isCorrect": false },
        { "id": 2, "text": "<Div>", "isCorrect": false },
        { "id": 3, "text": "<Fragment> (<>)", "isCorrect": true },
        { "id": 4, "text": "<List>", "isCorrect": false }
      ]
    },
    {
      "id": 10,
      "text": "У нас є масив з рядками (arr), кожен з яких хочемо відобразити на сторінці. Який метод масиву потрібно застосувати до return компонента?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "{arr.forEach(...)}", "isCorrect": false },
        { "id": 2, "text": "{arr.filter(...)}", "isCorrect": false },
        { "id": 3, "text": "{arr.for(...)}", "isCorrect": false },
        { "id": 4, "text": "{arr.map(...)}", "isCorrect": true }
      ]
    },
    {
      "id": 11,
      "text": "Який елемент використовується для обробки помилок у дереві компонентів?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "ErrorBoundary", "isCorrect": true },
        { "id": 2, "text": "CatchError", "isCorrect": false },
        { "id": 3, "text": "ErrorWrapper", "isCorrect": false },
        { "id": 4, "text": "ErrorCatcher", "isCorrect": false }
      ]
    },
    {
      "id": 12,
      "text": "Який (які) аргумент(и) приймає хук useMemo?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Функцію та масив залежностей", "isCorrect": true },
        { "id": 2, "text": "Функцію та об'єкт опцій", "isCorrect": false },
        { "id": 3, "text": "Функцію", "isCorrect": false },
        { "id": 4, "text": "Масив залежностей", "isCorrect": false }
      ]
    },
    {
      "id": 13,
      "text": "Для чого використовується хук useCallback в React?",
      "hasOptions": true,
      "options": [
        {
          "id": 1,
          "text": "Створення посилань на DOM елементи",
          "isCorrect": false
        },
        {
          "id": 2,
          "text": "Зберігання стану компонента",
          "isCorrect": false
        },
        {
          "id": 3,
          "text": "Виконання побічних ефектів",
          "isCorrect": false
        },
        { "id": 4, "text": "Мемоізації функцій", "isCorrect": true }
      ]
    },
    {
      "id": 14,
      "text": "Що відбувається, коли ви викликаєте setState?",
      "hasOptions": false,
      "answer": "Метод setState використовується в React для оновлення стану компонента. Коли ви викликаєте setState, React спочатку зберігає ваші зміни в черзі і потім об'єднує їх в один оновлений стан. Цей процес може бути асинхронним, і React може провести пакет оновлень разом для оптимізації продуктивності. Після оновлення стану React викликає метод render для відображення оновленого стану в DOM."
    },
    {
      "id": 15,
      "text": "Що таке refs в React?",
      "hasOptions": false,
      "answer": "Refs в React - це об'єкт, який дозволяє звертатися до вузлів DOM або до екземплярів компонентів в React. Refs найчастіше використовуються для отримання посилань на конкретний DOM-вузол або на екземпляр компонента, щоб здійснювати прямий доступ або здійснювати взаємодію з ними. Використовуються у випадках, коли прямий доступ до DOM-елементів або компонентів є необхідним і важливим для виконання конкретної логіки."
    },
    {
      "id": 16,
      "text": "У який момент життєвого циклу застосовуються запити AJAX і чому?",
      "hasOptions": false,
      "answer": "Запити AJAX в React застосовуються зазвичай в методі componentDidMount(). Це дозволяє виконати асинхронні запити до сервера, отримати дані та оновити стан компонента або викликати інші дії відповідно до отриманих даних. Використання componentDidMount() гарантує, що запит буде виконаний після того, як компонент вже має DOM-представлення, і сприяє уникненню помилок, пов'язаних з рендерингом компонентів до завершення AJAX-запиту."
    },
    {
      "id": 17,
      "text": "Опишіть, як в React обробляються події?",
      "hasOptions": false,
      "answer": "У React обробка подій відбувається за допомогою спеціальних властивостей та методів. Коли виникає подія, React передає об'єкт події, який містить інформацію про подію, у властивість, що вказує на функцію обробника. Наприклад, onClick для обробки кліку. Крім того, для збереження значення this у функції обробника, часто використовуються стрілкові функції або метод bind. React також має систему подій, яка дозволяє визначити і відписатися від подій компонента."
    },
    {
      "id": 18,
      "text": "Який другий аргумент можна опціонально передавати в setState і як це зробити?",
      "hasOptions": false,
      "answer": "Другий аргумент у функцію setState є опціональним і використовується для виконання дій після оновлення стану. Цей аргумент – це функція зворотного виклику, яка виконується після того, як стан був успішно оновлений. Це може бути використано для виконання коду, який залежить від нового стану. Наприклад, використання setState з функцією може виглядати так: setState(newState, () => { // додаткові дії після оновлення стану });"
    },
    {
      "id": 19,
      "text": "Як правильно звернутись до поточного стану при виклику setState?",
      "hasOptions": false,
      "answer": "При виклику setState у функції зворотного виклику (callback) можна користуватися аргументом, який представляє собою поточний стан. Наприклад, використовуючи функцію setState з функцією зворотного виклику, можна звернутися до поточного стану так: setState((prevState) => { // використання prevState для доступу до поточного стану // повернення нового стану на основі поточного });"
    },
    {
      "id": 20,
      "text": "Яку задачу вирішує React?",
      "hasOptions": false,
      "answer": "React є бібліотекою для розробки інтерфейсів користувача (UI). Вона допомагає вирішувати завдання створення декларативних, ефективних та простих у використанні компонентів інтерфейсу, які можна згрупувати в складніші структури та легко керувати їхнім станом та оновленнями."
    },
    {
      "id": 21,
      "text": "Як організовується потік даних у React через дерево компонентів?",
      "hasOptions": false,
      "answer": "У React потік даних впорядкований за деревом компонентів. Дані передаються вниз через властивості (props), а зміни стану (state) обробляються в компонентах. Існує також можливість використання контексту для передачі даних безпосередньо між компонентами без прямого прокидання через проміжні компоненти."
    },
    {
      "id": 22,
      "text": "Як відмінити завантаження даних з сервера в React?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Використати метод componentDidMount()", "isCorrect": false },
        { "id": 2, "text": "Використати метод componentWillUnmount()", "isCorrect": false },
        { "id": 3, "text": "Використати new AbortController().abort() для відміни запиту", "isCorrect": true },
        { "id": 4, "text": "Завантаження даних в React не можна зупинити", "isCorrect": false }
      ]
    },
    {
      "id": 23,
      "text": "Як здійснити передачу властивостей (props) в React?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Здійснюється автоматично, не потрібно вказувати", "isCorrect": false },
        { "id": 2, "text": "Використовуючи атрибут data в елементі", "isCorrect": false },
        { "id": 3, "text": "Встановлюючи властивість element.props у компоненті", "isCorrect": false },
        { "id": 4, "text": "Передаючи їх як атрибути в тег компонента при його виклику", "isCorrect": true }
      ]
    },
    {
      "id": 24,
      "text": "Як обробити подію кліку на кнопці в React?",
      "hasOptions": true,
      "options": [
        { "id": 1, "text": "Використовуючи подію onClick у компоненті", "isCorrect": true },
        { "id": 2, "text": "Використовуючи подію handleButton в розгалуженій структурі коду", "isCorrect": false },
        { "id": 3, "text": "Підписавшись на подію click кнопки через document.addEventListener", "isCorrect": false },
        { "id": 4, "text": "Задаючи атрибут onclick для кнопки", "isCorrect": false }
      ]
    }

  ]
}
